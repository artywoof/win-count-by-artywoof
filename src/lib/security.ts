// App Security & Anti-Reverse Engineering System
export class AppSecurity {
  private static readonly INTEGRITY_KEY = 'WIN_COUNT_INTEGRITY_CHECK';
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á Hash ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏≠‡∏û
  static async createAppHash(): Promise<string> {
    const appData = {
      name: 'Win Count by ArtYWoof',
      version: '1.0.0',
      timestamp: Date.now(),
      userAgent: navigator.userAgent
    };
    
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify(appData));
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    return hashHex;
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡∏Ç‡∏≠‡∏á‡πÅ‡∏≠‡∏û
  static async validateAppIntegrity(): Promise<boolean> {
    try {
      const currentHash = await this.createAppHash();
      const storedHash = localStorage.getItem(this.INTEGRITY_KEY);
      
      if (!storedHash) {
        localStorage.setItem(this.INTEGRITY_KEY, currentHash);
        return true;
      }
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏ú‡∏¥‡∏î‡∏õ‡∏Å‡∏ï‡∏¥
      if (storedHash !== currentHash) {
        console.warn('üö® App integrity compromised');
        return false;
      }
      
      return true;
    } catch (error) {
      console.error('‚ùå Security check failed:', error);
      return false;
    }
  }
  
  // ‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• License
  static async encryptLicenseData(data: string): Promise<string> {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    
    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
    const obfuscated = btoa(hashHex).split('').reverse().join('');
    return obfuscated;
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö License ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡∏´‡∏±‡∏™‡πÅ‡∏•‡πâ‡∏ß
  static async verifyLicenseData(encryptedData: string, originalData: string): Promise<boolean> {
    try {
      const expectedEncrypted = await this.encryptLicenseData(originalData);
      return encryptedData === expectedEncrypted;
    } catch (error) {
      console.error('‚ùå License verification failed:', error);
      return false;
    }
  }
  
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á Machine ID ‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
  static async generateSecureMachineId(): Promise<string> {
    try {
      const components = [
        navigator.userAgent,
        navigator.language,
        screen.width + 'x' + screen.height,
        new Date().getTimezoneOffset().toString(),
        navigator.hardwareConcurrency?.toString() || '0'
      ];
      
      const data = components.join('|');
      const encoder = new TextEncoder();
      const dataBuffer = encoder.encode(data);
      const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      
      return hashHex.substring(0, 16); // ‡πÉ‡∏ä‡πâ 16 ‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å
    } catch (error) {
      console.error('‚ùå Machine ID generation failed:', error);
      return 'fallback-machine-id';
    }
  }
  
  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏≠‡∏û
  static async detectTampering(): Promise<boolean> {
    try {
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á DOM
      const originalElements = document.querySelectorAll('*').length;
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á localStorage
      const originalStorage = JSON.stringify(localStorage);
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á sessionStorage
      const originalSession = JSON.stringify(sessionStorage);
      
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡∏≠‡∏á cookies
      const originalCookies = document.cookie;
      
      // ‡∏™‡∏£‡πâ‡∏≤‡∏á hash ‡∏Ç‡∏≠‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
      const currentState = {
        domElements: originalElements,
        localStorage: originalStorage,
        sessionStorage: originalSession,
        cookies: originalCookies,
        timestamp: Date.now()
      };
      
      const encoder = new TextEncoder();
      const data = encoder.encode(JSON.stringify(currentState));
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      
      const storedState = localStorage.getItem('app_state_hash');
      if (!storedState) {
        localStorage.setItem('app_state_hash', hashHex);
        return false; // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
      }
      
      return storedState !== hashHex;
    } catch (error) {
      console.error('‚ùå Tampering detection failed:', error);
      return false;
    }
  }
} 